## 02. Find Middle Node (중간 노드 찾기)

**문제**: Linked List의 중간 노드를 찾는 문제

**해결 방법**: Two Pointer (Floyd's Tortoise and Hare)

- `slow` 포인터는 한 번에 한 칸씩 이동
- `fast` 포인터는 한 번에 두 칸씩 이동
- `fast`가 끝에 도달하면 `slow`는 중간에 위치

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 03. Has Loop (순환 검출)

**문제**: Linked List에 순환(cycle)이 있는지 검사

**해결 방법**: Floyd's Cycle Detection Algorithm

- 두 포인터를 다른 속도로 이동시켜 만나면 순환 존재

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 04. Find K-th Node from End (끝에서 K번째 노드)

**문제**: 끝에서부터 K번째 노드를 찾는 문제

**해결 방법**: Two Pointer Technique

- `fast` 포인터를 먼저 K-1만큼 이동
- 그 다음 두 포인터를 함께 이동하면 `slow`가 목표 위치에 도달

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 05. Remove Duplicates (중복 제거)

**문제**: 정렬되지 않은 Linked List에서 중복 값 제거

**해결 방법**: Hash Set 사용

- `set`으로 이미 본 값들을 추적
- 중복 발견 시 연결을 건너뛰어 제거

**시간복잡도**: O(n), **공간복잡도**: O(n)

---

## 06. Binary to Decimal (이진수를 십진수로)

**문제**: 이진수를 나타내는 Linked List를 십진수로 변환

**해결 방법**: 왼쪽부터 순회하며 누적 계산

- 각 단계마다 기존 값에 2를 곱하고 현재 비트를 더함

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 07. Partition List (리스트 분할)

**문제**: 주어진 값을 기준으로 작은 값들을 앞으로, 큰 값들을 뒤로 분할

**해결 방법**: Two Dummy Nodes

- 작은 값들과 큰/같은 값들을 각각 별도 리스트로 구성
- 마지막에 두 리스트를 연결

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 08. Reverse Between (구간 역순)

**문제**: 주어진 시작과 끝 인덱스 사이의 노드들을 역순으로 배치

**해결 방법**: Dummy Node + 반복적 앞으로 이동

- 역순할 구간의 바로 앞 노드를 찾음
- 구간 내 노드들을 하나씩 맨 앞으로 이동

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 09. Swap Nodes in Pairs (인접 노드 쌍 교환)

**문제**: 인접한 두 노드씩 쌍을 이루어 위치를 교환

**해결 방법**: Dummy Node + 포인터 조작

- 매 두 노드씩 위치를 바꿈
- dummy 노드로 head 변경을 간단히 처리

**시간복잡도**: O(n), **공간복잡도**: O(1)

---

## 핵심 패턴 정리 (상세)

### 1. Two Pointer Technique (투 포인터 기법)

**언제 사용하나?**

- 리스트의 특정 위치를 찾아야 할 때
- 순환을 검출해야 할 때
- 한 번의 순회로 여러 정보를 얻어야 할 때

**세부 패턴들:**

#### 1-1. Slow/Fast Pointer (토끼와 거북이)

- **사용 목적**: 중간 지점 찾기, 순환 검출
- **핵심 아이디어**: 서로 다른 속도로 이동하여 만나는 지점의 의미를 활용
- **적용 문제**: 중간 노드 찾기, 순환 검출
- **주의점**: `fast.next`가 null인지 항상 확인

#### 1-2. Gap Pointer (간격 포인터)

- **사용 목적**: 끝에서부터의 위치 계산
- **핵심 아이디어**: 두 포인터 사이에 고정된 간격을 유지
- **적용 문제**: 끝에서 K번째 노드 찾기
- **구현 순서**:
  1. fast를 K-1만큼 먼저 이동
  2. slow와 fast를 함께 이동
  3. fast가 끝에 도달하면 slow가 목표 위치

### 2. Dummy Node 활용

**언제 사용하나?**

- head가 변경될 가능성이 있을 때
- 리스트를 분할하거나 재구성해야 할 때
- edge case 처리를 단순화하고 싶을 때

**사용 패턴들:**

#### 2-1. Single Dummy Node

- **사용 목적**: head 변경을 간단하게 처리
- **적용 문제**: 노드 쌍 교환, 구간 역순
- **장점**: head가 바뀌어도 일관된 처리 가능

#### 2-2. Multiple Dummy Nodes

- **사용 목적**: 여러 그룹으로 분할
- **적용 문제**: 리스트 분할 (작은 값 vs 큰 값)
- **패턴**: 각 그룹마다 별도의 dummy와 tail 포인터 유지

### 3. Hash Set 사용

**언제 사용하나?**

- 중복을 검출하거나 제거해야 할 때
- 이전에 방문한 노드를 기억해야 할 때
- O(1) 조회 시간이 필요할 때

**트레이드오프:**

- **시간복잡도**: O(n) - 각 노드를 한 번씩만 방문
- **공간복잡도**: O(n) - 값들을 저장하는 추가 공간 필요
- **적용 문제**: 중복 제거 (정렬되지 않은 리스트)

### 4. 포인터 조작 기법

**핵심 원칙:**

- **안전한 순서**: 연결을 끊기 전에 새로운 연결 먼저 설정
- **임시 변수 활용**: 다음 노드를 미리 저장
- **prev 포인터 관리**: 이전 노드와의 연결 유지

**세부 기법들:**

#### 4-1. 역순 재배치

- **방법**: 노드를 하나씩 앞으로 이동
- **적용**: 구간 역순
- **핵심**: `to_move`를 `prev.next` 위치로 이동

#### 4-2. 쌍 교환

- **방법**: 인접한 두 노드의 위치 바꿈
- **패턴**: current와 next의 연결 관계를 조작

### 5. 수학적/논리적 접근

**이진수 변환 패턴:**

- **핵심 아이디어**: 왼쪽부터 읽으며 `result = result * 2 + digit`
- **일반화**: 진법 변환이나 문자열 처리에도 응용 가능

---

## 문제 해결 전략

### Step 1: 문제 유형 파악

- **위치 찾기** → Two Pointer 고려
- **구조 변경** → Dummy Node 고려
- **중복 처리** → Hash Set 고려
- **순서 바꾸기** → 포인터 조작 기법

### Step 2: Edge Case 확인

- 빈 리스트 (head == null)
- 단일 노드 (head.next == null)
- 매개변수 검증 (k > 리스트 길이 등)

### Step 3: 시간/공간 복잡도 고려

- **O(1) 공간**이 필요하면 Two Pointer나 포인터 조작
- **O(n) 공간**을 허용하면 Hash 구조 활용 가능
